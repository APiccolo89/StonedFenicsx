# Computational domain

(fig:f1_simplified_initial_setup)=
```{figure} images_doc/Initial_setup.png
:width: 500px

Simplified initial computational domain.

This section is based on the supplementary material section of the paper that is going to be published out of this project. 

The computational domain is generated using `gmsh` and consists of an unstructured triangular mesh {cite}`geuzaine2009gmsh`.  
In **{numref}`fig:f1_simplified_initial_setup`**, we sketch a simplified initial computational domain.  
This sketch highlights the features that are common to all numerical realisations.

The main portions of the numerical domain are shown using different colours, the points defining the physical boundaries are labelled with capital letters (`A–L`), and the boundaries are denoted by bracketed lowercase letters (**[a–i]**).


## *Domain geometry*

The main computational domain can be approximated by a trapezoid defined by `A`, `B`, `C`, `D`, `E`, and `F`.  
The computational domain extends from the surface \(0\) km to a maximum depth of \(-600\) km.

The horizontal extent of the numerical domain (i.e., the coordinate `x` of `F` and `E`) depends on the slab geometry.

- Point `A` represents the origin with coordinates \(0, 0\) km.
- Point `B` represents the base of the subducting plate at \(0, -140)\ km.
- Points `C` and `D` have coordinates  
  \(x_b, -600\) km and \(x_t, -600\) km,  
  where \(x_b)\ and \(x_t\) depend on the chosen slab geometry.
- Points `E` and `F` are the rightmost points with coordinates  
  \(x_t + 60, -600\) km and \(x_t + 60, 0)\ km, respectively.


## **Subdomains**

The initial setup is divided into three subdomains:

- *Slab (S)*
- *Wedge (W)*
- *Overriding plate (OP)*

These are coloured red, yellow, and grey, respectively.

The subdivision is generated by two internal boundaries:

- the *top surface of the slab*
- the *overriding-plate boundary*

corresponding to lines `[a]` and `[b]` in **{numref}`fig:f1_simplified_initial_setup`**.

The top surface of the slab (`[a]`) represents the **kinematic boundary condition** that drives the velocity field of the entire numerical domain.  
Velocity is imposed **parallel to the slab surface**, with magnitude equal to the prescribed convergence velocity.

The base of the *overriding plate* is treated as a *no-slip boundary*.


## **Governing-equation domains**

The subdivision into three smaller domains simplifies the computation of the **Stokes equations**:

- 'Mass and momentum conservation' are solved only in *S* and *W*.
- 'Lithostatic pressure' and 'energy conservation' are solved in the **entire domain**.

The subdomains are independent, non-overlapping computational regions, defined by boundaries that may be shared with neighbouring subdomains.

Each subdomain can contain different material properties. For example, the overriding plate may include crustal units and lithospheric mantle, which primarily affect **thermal properties**.

In the following sections, we first describe the Stokes subdomains (slab and wedge) and their boundary conditions. We then discuss the thermal boundary conditions applied to the global domain.

```{math}
\mathbf{G} = \mathbf{OP} + \mathbf{S} + \mathbf{W}.
```
## Domains

### Slab

In {numref}`fig:f1_simplified_initial_setup`, **S** is shown in red and is defined by points `A`, `B`, `C`, and `D`. It is bounded by four boundaries: `[a]`, `[c]`, `[d]`, and `[e]`.

On `[a]`, we prescribe an **internal moving-wall boundary condition**. The velocity \(v_c\) represents the convergence velocity and is locally parallel to the tangent of `[a]`. Its magnitude is constant and equal to \(v_c\). Boundary `[c]` is the **base of the plate**, where a **free-slip boundary condition** is applied using the Nitsche method {cite}`sime2020automatic,sime2024thermal`. Boundaries `[d]` and `[e]` are **open boundaries**, whose inflow or outflow velocities depend on the convergence velocity applied on `[a]`.

The viscosity within **S** is constant and equal to {math}`\eta_{\mathrm{slab}}`, regardless of the number of material phases. This allows the **Stokes equations** to be solved only once per numerical realisation, both for steady-state and time-dependent problems.

The slab may contain different material phases (lithospheric mantle and oceanic crust), each with distinct **heat capacity, density, and conductivity**.

### Wedge

The **W** subdomain is defined by points `H`, `D`, `E`, and `F` (see {numref}`fig:f1_simplified_initial_setup`).  It is bounded by a portion of `[a]` (from `H` to `D`) and by `[f]`, `[g]`, and `[b]`. Boundaries `[f]` and `[g]` are **open (do-nothing) boundaries**:

- `[f]` is mostly **outflow**, although inflow may occur depending on position.  
- `[g]` can exhibit **both inflow and outflow** depending on wedge rheology.

On `[b]`, a **no-slip boundary condition** is imposed. Only part of `[a]` controls the wedge kinematics. As in the slab, a **moving-wall boundary condition** is prescribed, but a shallow segment simulates **partial decoupling** between wedge and slab (similar to {cite}`van2023introductory`).

Two approaches exist:

1. Introduce a **weak phase** between wedge and slab {cite}`wada2009common`.  
2. Explicitly define a **decoupling depth** \(d_c\) and smoothly vary the velocity  
   {cite}`van2023introductory,sime2024thermal,hobson2025sensitivity`.

Both are valid; here we adopt the **explicit decoupling depth**, as it is easier to treat as a free parameter {cite}`hobson2025sensitivity`.

#### Velocity scaling along the slab

The decoupled portion of `[a]` lies between points `H` and `I`. The slab-parallel unit vector is multiplied by the convergence velocity and a **scaling function** adapted from {cite}`hobson2025sensitivity`.

(eq:scaling_function)=
```{math}
sc(z) = \frac{1}{2}\left[1 + \tanh\!\left(\frac{z - d_c}{\delta z_{tr}}\right)\right]
```


where {math}`z` is the depth coordinate, {math}`d_c` is the decoupling depth, and {math}`\delta z_{tr}` is the transition distance from fully decoupled to fully coupled ({math}`\delta z_{tr} = 10/4` km). The velocity along `[a]` in the wedge is then:

(eq:velocity_jump)=
```{math}
\mathbf{v}_{slab} = sc(z)\, v_{mag}\, \hat{\mathbf{v}}_{slab}
```

where {math}`\mathbf{v}_{slab}` is the effective slab velocity and {math}`\hat{\mathbf{v}}_{slab}` is the unit vector parallel to the local tangent of the slab surface.

### Global domains

At each iteration and/or time step, the velocity and dynamic pressure field computed in **S** and **W** are interpolated back onto the global domain mesh. The velocity is used for solving the energy conservation equation. We briefly describe the boundary conditions prescribed at the external boundaries of the global domain.

At the top boundary (`[h]` in **Fig.** {ref}`fig:f1_simplified_initial_setup`), an isothermal boundary condition is imposed, where the temperature is equal to the surface temperature {math}`T_{s}`. At the open boundaries, such as `[d]`, `[f]`, and `[g]`, the prescribed boundary conditions depend on the velocity vector: if there is an inflow velocity within these boundaries, the portion of the boundary becomes isothermal, with a temperature equal to the mantle potential temperature; if there is an outflow velocity field, the local boundary condition is no-flux. The only exception to this general rule is a portion of `[g]` (from point `L` to `F`). The depth of point `L` can be an independent parameter, but for convenience is always equal to {math}`d_c`. Within this portion of `[g]`, the boundary condition is no-flux regardless of the velocity field. This strategy allows simulation of a realistic lithosphere temperature field.

At boundaries `[e]` and `[i]`, the temperature is prescribed as a function of depth. For `[i]`, the temperature varies linearly with depth, and the linear gradient is computed as

```{math}
gr = \frac{(T_{p} - T_{s})}{d_c}
```

where {math}`T_p` is the mantle potential temperature. Before initialisation of the experiment, an initial guess of the temperature field is computed assuming a continental-like thermal structure everywhere. This continental-like geotherm uses the decoupling depth (or the depth of point `L`) as the effective base of the lithosphere.

For boundary `[e]`, the temperature structure is either computed analytically using a half-space cooling model with a given age {cite}`turcotte2014geodynamics,van2008community`, or computed numerically. We adopt the plate model described in {cite}`richards2020structure` and solve the numerical energy conservation equation without the advection term on a 1D numerical domain extending from −140 to 0 km. The temperature at the top is always the surface temperature, while the bottom temperature can be either the mantle potential temperature or the adiabatic temperature if adiabatic processes are active.

The numerical method used to compute the thermal structure of the incoming plate (i.e., the prescribed temperature at boundary `[e]`) is a finite-difference Crank–Nicolson scheme, similar to {cite}`richards2020structure,van2023effect`. The numerical scheme is described in the appendix of {cite}`van2023effect`; in the present work, a Picard iteration scheme is added to handle nonlinearities and compute the lithostatic pressure. The lithostatic pressure is obtained from a depth-dependent integral of rock density. We solve the time-dependent energy conservation equation without the advective term, and the residual is evaluated using Eq. XX with a tolerance of {math}`10^{-5}`. The lithostatic pressure is computed once per time step, prior to solving the energy equation, accounting for nonlinearities using the current temperature field.

### Overriding plate 

The overriding plate is composed of either mantle, or mantle and crustal unit, as a function of the input parameters. It is a separated domain, but without any specific FEM problem associated. 

## Module create mesh 

The mesh-generation submodule requires a set of geometric inputs, which are used to populate the Geom_input dataclass. This class stores the geometry needed to construct the computational domain. The create_mesh.py module first generates the slab top surface and then defines the geometric entities specified by the user. The mesh is generated with gmsh and written to the output directory. The resulting .msh file is then read, converted into a dolfinx mesh, and passed to the main solver.

### Geometry of the subducting plate 

The geometry of the top surface slab can be either a parametrised curve or a real slab geometry (not yet implemented). The parametrised curve requires the following parameters: 

- {math}`s_{tk}` slab thickness, the thickness of the subudcting plate in meters, and always positive.
- {math}`\theta_{max}` the maximum bending angle. 
- {math}`\theta_{0}` the minimum bending angle.
- {math}`L_{b}` the critical along the slab distance in meters and always positive. 
- {math}`F_{vk}` flag of constant bending angle. 
- {math}`d\ell` length of the slab segment.
- {math}`X_{trench}` coordinate of the trench in meters. 


if {math}`F_{vk}` is active, {math}`\theta_{max}` becomes the constant angle of the slab. This feature is mostly used for benchmarking purpose (i.e., for reproducing the benchmarks of {cite}`van2008community`). 

The parametrised slab surface is computed using {math}`d\ell` and a function that describe {math}`\theta(\ell0)`. The function that describe the evolution of the bending angle as a function of the cumulative arc-length distance along the slab surface from the trench ({math}`\ell`) is: 

```{math}
\theta(\ell) =
\begin{cases}
\theta_{\max}\, \ell^{2}\, \dfrac{3L_b - 2\ell}{L_b^{3}}, & \text{if } \ell \le L_b, \\
\theta_{\max}, & \text{otherwise.}
\end{cases}
```
The algorithm starts from the trench. It computes {math}`\theta(\ell(trench))` at the trench position, and {math}`\theta(\ell(trench)+d\ell)`. It averages the two angle, and then compute the coordinate of the new point of the slab: 
```{math}
:label: eq:trench_update

\mathbf{X}_{\text{new}}
=
\mathbf{X}_{\text{trench}}
+
d\ell \, \hat{\mathbf{t}},
\qquad
\hat{\mathbf{t}} = (\cos\theta, -\sin\theta).
```
Then repeat the same operation starting from the new coordinate points till the coordinate_y is equal to the maximum depth of the model.

The bottom of the slab and the bottom of the potential oceanic crust layer are computed using the top surface using the following equations:
```{math}
:label: eq:bottom_slab
\mathbf{X}_{\mathrm{bot}}(\ell)
=
\mathbf{X}_{\mathrm{top}}(\ell)
+
s_{tk}\,\hat{\mathbf{n}}(\ell),
\qquad
\hat{\mathbf{n}}(\ell)=(-\sin\theta(\ell),\,-\cos\theta(\ell)).
```
where {math}`\mathbf{X}_{bot}(\ell)` is the array containing the coordinate of either the bottom of the subducting plate or the oceanic crust's moho and {math}`\mathbf{X}_{top}(\ell)` is the coordinate array of the top surface of the subducting plate.  



## References

```{bibliography}
:all:
```